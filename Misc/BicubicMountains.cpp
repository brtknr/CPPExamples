#include <iostream>#include <fstream>#include <cmath>#include <cstdlib>using namespace std;#define mPlus1  513double MyRandom(void);void Skew(void);void PlotMountains(void);void PlotWater(void);double x[mPlus1][mPlus1],y[mPlus1][mPlus1],z[mPlus1][mPlus1],waterlevel[mPlus1],radiusfactor[mPlus1],       Grid,tempdouble,biggest,smallest,root2,factor,       PI,a,b,basebottom,lengthscale,lambda,theta;int i,j,m,mtemp,step,stepover2,which;ofstream Julia("BicubicMountains.dxf");int main(void){PI=4.0*atan(1.0);a=sqrt(2.0/(4.0-PI));b=sqrt(4.0/PI-1.0);m=mPlus1-1;biggest=0.0;smallest=0.0;for(i=1;i<=10000;i++){tempdouble=MyRandom();if(biggest<tempdouble)biggest=tempdouble;if(smallest>tempdouble)smallest=tempdouble;}cout<<smallest<<"  "<<biggest<<"\n";mtemp=1;for(;;){mtemp=2*mtemp;if(mtemp>=m)break;}if(mtemp!=m){cout<<"Problem with m\n";return 0;}Grid=10.0;root2=sqrt(2.0);basebottom=-0.04*m*Grid;lengthscale=1.0*m*Grid;lambda=1.0;for(i=0;i<=m;i++){for(j=0;j<=m;j++){radiusfactor[i]=exp(((2.0*i-1.0*m)/(2.0*m))*lambda);              theta=((2.0*j-1.0*m)/(2.0*m))*lambda;x[i][j]=Grid*m*radiusfactor[i]*cos(theta);y[i][j]=Grid*m*radiusfactor[i]*sin(theta);}}Julia<<"0\nSECTION\n2\nENTITIES\n";for(which=1;which<=2;which++){if(which==1)factor=0.2;else factor=0.02;if(which==1)step=m/2;else step=m/32;for(i=0;i<=m;i+=step){for(j=0;j<=m;j+=step){z[i][j]=radiusfactor[i]*factor*step*Grid*MyRandom();if(which==1){z[i][j]+=(0.14+(0.01*i)/(1.0*m))*m*Grid;if(i==0)z[i][j]=0.0;}}}for(;;){cout<<step<<"\n";stepover2=step/2;for(i=stepover2;i<=m-stepover2;i+=step){for(j=stepover2;j<=m-stepover2;j+=step){if(i>=3*stepover2&&i<=m-3*stepover2&&   j>=3*stepover2&&j<=m-3*stepover2){z[i][j]=z[i-3*stepover2][j-3*stepover2]+z[i+3*stepover2][j-3*stepover2]+z[i+3*stepover2][j+3*stepover2]+z[i-3*stepover2][j+3*stepover2];z[i][j]-=9.0*(z[i-stepover2][j-3*stepover2]+z[i+stepover2][j-3*stepover2]+z[i+stepover2][j+3*stepover2]+z[i-stepover2][j+3*stepover2]             +z[i-3*stepover2][j-stepover2]+z[i+3*stepover2][j-stepover2]+z[i+3*stepover2][j+stepover2]+z[i-3*stepover2][j+stepover2]);z[i][j]+=81.0*(z[i-stepover2][j-stepover2]+z[i+stepover2][j-stepover2]+z[i+stepover2][j+stepover2]+z[i-stepover2][j+stepover2]);z[i][j]=z[i][j]/256.0;}else{z[i][j]=(z[i-stepover2][j-stepover2]+z[i+stepover2][j-stepover2]+z[i+stepover2][j+stepover2]+z[i-stepover2][j+stepover2])/4.0;}z[i][j]+=exp(z[i][j]/lengthscale)*radiusfactor[i]*factor*step*Grid*MyRandom()/root2;}}for(i=0;i<=m;i+=step){for(j=stepover2;j<=m-stepover2;j+=step)Skew();}for(i=stepover2;i<=m-stepover2;i+=step){for(j=0;j<=m;j+=step)Skew();}step=step/2;if((which==1&&step==1)||(which==2&&step==2))break;}if(which==1)PlotMountains();else PlotWater();}Julia<<"0\nENDSEC\n0\nEOF\n";Julia.close();cout<<"Finished\n";return 0;}double MyRandom(void){double JuliaRandom;JuliaRandom=0.99*(rand()/32768.0-0.5);JuliaRandom=(1.0/(2.0*a))*log((1.0+2.0*JuliaRandom)/(1.0-2.0*JuliaRandom));JuliaRandom=(1.0/b)*log(JuliaRandom+sqrt(JuliaRandom*JuliaRandom+1.0));return JuliaRandom;}void Skew(void){double bottom;if(i>=3*stepover2&&i<=m-3*stepover2&&   j>=3*stepover2&&j<=m-3*stepover2){z[i][j]=z[i-3*stepover2][j]+z[i][j-3*stepover2]+z[i+3*stepover2][j]+z[i][j+3*stepover2];z[i][j]-=9.0*(z[i-step][j-stepover2]+z[i+step][j-stepover2]+z[i+step][j+stepover2]+z[i-step][j+stepover2]             +z[i-stepover2][j-step]+z[i+stepover2][j-step]+z[i+stepover2][j+step]+z[i-stepover2][j+step]);z[i][j]+=81.0*(z[i-stepover2][j]+z[i][j-stepover2]+z[i+stepover2][j]+z[i][j+stepover2]);z[i][j]=z[i][j]/256.0;}else{bottom=0.0;z[i][j]=0.0;if(i>=stepover2)  {z[i][j]+=z[i-stepover2][j];bottom+=1.0;}if(i<=m-stepover2){z[i][j]+=z[i+stepover2][j];bottom+=1.0;}if(j>=stepover2)  {z[i][j]+=z[i][j-stepover2];bottom+=1.0;}if(j<=m-stepover2){z[i][j]+=z[i][j+stepover2];bottom+=1.0;}z[i][j]=z[i][j]/bottom;}z[i][j]+=exp(z[i][j]/lengthscale)*radiusfactor[i]*factor*step*Grid*MyRandom()/2.0;}void PlotMountains(void){for(i=0;i<=m-1;i++){for(j=0;j<=m-1;j++){Julia<<"0\n3DFACE\n8\nMount\n";Julia<<"10\n"<<x[i][j]<<"\n";Julia<<"20\n"<<y[i][j]<<"\n";Julia<<"30\n"<<z[i][j]<<"\n";Julia<<"11\n"<<x[i+1][j]<<"\n";Julia<<"21\n"<<y[i+1][j]<<"\n";Julia<<"31\n"<<z[i+1][j]<<"\n";Julia<<"12\n"<<x[i+1][j+1]<<"\n";Julia<<"22\n"<<y[i+1][j+1]<<"\n";Julia<<"32\n"<<z[i+1][j+1]<<"\n";Julia<<"13\n"<<x[i][j+1]<<"\n";Julia<<"23\n"<<y[i][j+1]<<"\n";Julia<<"33\n"<<z[i][j+1]<<"\n";}}for(j=0;j<=m;j+=m){for(i=0;i<=m-1;i++){Julia<<"0\n3DFACE\n8\nSide\n";Julia<<"10\n"<<x[i][j]<<"\n";Julia<<"20\n"<<y[i][j]<<"\n";Julia<<"30\n"<<z[i][j]<<"\n";Julia<<"11\n"<<x[i+1][j]<<"\n";Julia<<"21\n"<<y[i+1][j]<<"\n";Julia<<"31\n"<<z[i+1][j]<<"\n";Julia<<"12\n"<<x[i+1][j]<<"\n";Julia<<"22\n"<<y[i+1][j]<<"\n";Julia<<"32\n"<<basebottom<<"\n";Julia<<"13\n"<<x[i][j]<<"\n";Julia<<"23\n"<<y[i][j]<<"\n";Julia<<"33\n"<<basebottom<<"\n";}}for(i=0;i<=m;i+=m){for(j=0;j<=m-1;j++){Julia<<"0\n3DFACE\n8\nSide\n";Julia<<"10\n"<<x[i][j]<<"\n";Julia<<"20\n"<<y[i][j]<<"\n";Julia<<"30\n"<<z[i][j]<<"\n";Julia<<"11\n"<<x[i][j+1]<<"\n";Julia<<"21\n"<<y[i][j+1]<<"\n";Julia<<"31\n"<<z[i][j+1]<<"\n";Julia<<"12\n"<<x[i][j+1]<<"\n";Julia<<"22\n"<<y[i][j+1]<<"\n";Julia<<"32\n"<<basebottom<<"\n";Julia<<"13\n"<<x[i][j]<<"\n";Julia<<"23\n"<<y[i][j]<<"\n";Julia<<"33\n"<<basebottom<<"\n";}}}void PlotWater(void){for(i=0;i<=m-step;i+=step){for(j=0;j<=m-step;j+=step){Julia<<"0\n3DFACE\n8\nWater\n";Julia<<"10\n"<<x[i][j]<<"\n";Julia<<"20\n"<<y[i][j]<<"\n";Julia<<"30\n"<<z[i][j]<<"\n";Julia<<"11\n"<<x[i+step][j]<<"\n";Julia<<"21\n"<<y[i+step][j]<<"\n";Julia<<"31\n"<<z[i+step][j]<<"\n";Julia<<"12\n"<<x[i+step][j+step]<<"\n";Julia<<"22\n"<<y[i+step][j+step]<<"\n";Julia<<"32\n"<<z[i+step][j+step]<<"\n";Julia<<"13\n"<<x[i][j+step]<<"\n";Julia<<"23\n"<<y[i][j+step]<<"\n";Julia<<"33\n"<<z[i][j+step]<<"\n";}}}